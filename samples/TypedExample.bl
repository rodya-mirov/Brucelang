// NB: this assumes you load a previous library that defines `derp: Integer` somewhere in it

// this is a good variable name, I have high hopes for it
define f(arg: Integer): Integer as {
    let helpful: Integer = (x: Integer => x*arg)(12);
    let moreHelpful: Integer = ((a: Integer, b: Integer) => (a/b)-arg)(34, 55);
    return helpful;
}

let chomp: Fn<Integer, Integer> = food: Integer =>
    (a: Integer => {
        let x: Integer = 12;
        return a + x;
    })(food);

let curry: Fn<Fn<Integer, Integer, Integer, Integer, Integer>, Fn<Integer, Integer>>
        = func: Fn<Integer, Integer, Integer, Integer, Integer> => (x: Integer => func(x, 2, 3, 4));

define g(zed: Integer): Integer as {
    define h(a: Integer, b: Integer, c: Integer, d: Integer): Integer as {
        return a + b + f(c + d);
    }

    let curryPowder: Fn<Integer, Integer> = curry(h);

    if (1 < 3) {
        return curryPowder(f(1));
    } else if (2 < 3) {
        do 15+17;
        return (() => 12)();
    } else {
        return 1413;
    }
}

define main(): Integer as {
    let x: Integer = 13 + 14;
    let y: Integer = 13 * (x - f(12));

    return x - g(y) * chomp(18);
}

do main() - derp;
