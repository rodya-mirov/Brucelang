// NB: this assumes you load a previous library that defines `derp: Integer` somewhere in it

do !(true);

let zombie = x:Integer => {
    let helper: Fn(Integer) -> Integer = a: Integer => x*a;
    return helper(12);
};

// this is a good variable name, I have high hopes for it
define f(arg: Integer): Integer as {
    let helpful: Integer = (x: Integer => x*arg)(12);
    let moreHelpful: Integer = ((a: Integer, b: Integer) => (a/b)-arg)(34, 55);
    return helpful;
}

let chomp = food: Integer =>
    (a: Integer => {
        let x: Integer = 12;
        return a + x;
    })(food);

// note we don't have to have any type here, except for function arguments ...
let curry = func: Fn(Integer, Integer, Integer, Integer) -> Integer => (x: Integer => func(x, 2, 3, 4));

// ... but the "define" syntax requires a return type, just for sake of syntax
define g(zed: Integer): Integer as {
    define h(a: Integer, b: Integer, c: Integer, d: Integer): Integer as {
        return a + b + f(c + d);
    }

    // type inference here, you might actually be happier declaring the type
    let curryPowder = curry(h);

    if (1 < 3) {
        return curryPowder(f(1));
    } else if (2 < 3) {
        do 15+17;
        return (() => 12)();
    } else {
        return 1413;
    }
}

define main(): Integer as {
    let x: Integer = 13 + 14;
    let y = 13 * (x - f(12));

    return x - g(y) * chomp(18);
}

do main() - derp;
